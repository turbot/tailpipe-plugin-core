name: Test Cross-Compile

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version (without 'v')"
        required: true
        default: 0.1.\invalid

env:
  ORG: turbot
  CR: ghcr.io
  CR_PREFIX: turbot/tailpipe/plugins
  CONFIG_SCHEMA_VERSION: '2020-11-18'
  ORAS_VERSION: 1.1.0
  PIPELING: tailpipe

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Output pipeling name
        run: |
          echo "Pipeling name: ${{ env.PIPELING }}"
          echo "PIPELING_NAME=${{ env.PIPELING }}" >> $GITHUB_ENV

      - name: Checkout
        uses: actions/checkout@v4
        with:
          path: ${{ env.PIPELING }}-plugin
          fetch-depth: 0
      - name: Set environment variables
        run: |
          plugin_name=$(echo $GITHUB_REPOSITORY | cut -d'-' -f 3)
          echo $plugin_name
          echo "PLUGIN_NAME=${plugin_name}" >> $GITHUB_ENV
      # Exit early if we don't need to build
      - name: Exit if goreleaser file is missing
        run: |
          cd ${{ env.PIPELING }}-plugin
          test -f .goreleaser.yml
      - name: Set Version
        run: |
          echo "VERSION=v${{inputs.version}}" >> $GITHUB_ENV
      # this is required, check golangci-lint-action docs
      - uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: false # setup-go v4 caches by default, do not change this parameter, check golangci-lint-action doc: https://github.com/golangci/golangci-lint-action/pull/704
      - name: Run Goreleaser (via container in Makefile target)
        run: |-
          cd ${{ env.PIPELING }}-plugin
          make release
      - name: List Build Artifacts
        run: |
          cd ${{ env.PIPELING }}-plugin
          ls -laR ./dist
      # Copy artifacts into working dir
      - name: Copy artifacts and docs to working dir
        run: |
          cp ./${{ env.PIPELING }}-plugin/dist/*.gz .
          cp -R ./${{ env.PIPELING }}-plugin/docs .
          ls -al
      # Create files for registry
      - name: Create config file
        run: |-
          JSON_STRING=$( jq -n \
                    --arg name "$PLUGIN_NAME" \
                    --arg organization "$ORG" \
                    --arg version "$VERSION" \
                    --arg schemaVersion "$CONFIG_SCHEMA_VERSION" \
                    '{schemaVersion: $schemaVersion, plugin: { name: $name, organization: $organization, version: $version} }' )
          echo $JSON_STRING > config.json

      - name: Create annotations file
        run: |-
          JSON_STRING=$( jq -n \
                   --arg title "$PLUGIN_NAME" \
                   --arg desc "$ORG" \
                   --arg version "$VERSION" \
                   --arg timestamp "$(date +%FT%T%z | sed 's/\([0-9][0-9]\)\([0-9][0-9]\)$/\1:\2/')" \
                   --arg repo "$GITHUB_SERVER_URL/$GITHUB_REPOSITORY" \
                   --arg commit "$GITHUB_SHA" \
                   --arg vendor "Turbot HQ, Inc." \
                 '{
                   "$manifest": {
                       "org.opencontainers.image.title": $title,
                       "org.opencontainers.image.description": $desc,
                       "org.opencontainers.image.version": $version,
                       "org.opencontainers.image.created": $timestamp,
                       "org.opencontainers.image.source": $repo,
                       "org.opencontainers.image.revision": $commit,
                       "org.opencontainers.image.vendor":  $vendor
                   }
                 }' )
           echo $JSON_STRING > annotations.json

      - name: View annotations
        run: |
          cat annotations.json

      - name: View README
        run: |
          cd ${{ env.PIPELING }}-plugin
          cat README.md

      # Setup ORAS
      - name: Install specific version of ORAS
        run: |
          curl -LO https://github.com/oras-project/oras/releases/download/v${ORAS_VERSION}/oras_${ORAS_VERSION}_linux_amd64.tar.gz
          sudo tar xzf oras_${ORAS_VERSION}_linux_amd64.tar.gz -C /usr/local/bin oras
          oras version

      # Login to GHCR
      - name: Log in to the Container registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.CR }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Publish to GHCR
      - name: Push to the container registry (tailpipe)
        run: |
          REF="$CR/$CR_PREFIX/$ORG/$PLUGIN_NAME:$VERSION"
          LATEST_REF="$CR/$CR_PREFIX/$ORG/$PLUGIN_NAME:latest"
          oras push $REF \
            --config config.json:application/vnd.turbot.${{ env.PIPELING }}.config.v1+json \
            --annotation-file annotations.json \
            ${{ env.PIPELING }}-plugin-${PLUGIN_NAME}_darwin_amd64.gz:application/vnd.turbot.${{ env.PIPELING }}.plugin.darwin-amd64.layer.v1+gzip \
            ${{ env.PIPELING }}-plugin-${PLUGIN_NAME}_darwin_arm64.gz:application/vnd.turbot.${{ env.PIPELING }}.plugin.darwin-arm64.layer.v1+gzip \
            ${{ env.PIPELING }}-plugin-${PLUGIN_NAME}_linux_amd64.gz:application/vnd.turbot.${{ env.PIPELING }}.plugin.linux-amd64.layer.v1+gzip \
            ${{ env.PIPELING }}-plugin-${PLUGIN_NAME}_linux_arm64.gz:application/vnd.turbot.${{ env.PIPELING }}.plugin.linux-arm64.layer.v1+gzip \
            docs:application/vnd.turbot.${{ env.PIPELING }}.plugin.docs.layer.v1+tar

          # tag the image with the GitHub Run ID for traceability
          oras tag $REF $GITHUB_RUN_ID

          # check if the version is NOT an rc version before tagging as latest
          if [[ $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Tagging as latest: $LATEST_REF"
            oras tag $REF $LATEST_REF
          else
            echo "Skipping latest tag for rc version: $VERSION"
          fi